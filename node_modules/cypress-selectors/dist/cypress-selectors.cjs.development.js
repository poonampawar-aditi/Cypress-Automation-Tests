'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lodash = require('lodash');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var Logger = {
  LOG_PREFIX: "[cypress-selectors]",
  logSelector: function logSelector(selector, propertyPath, level) {
    if (level === void 0) {
      level = 'info';
    }

    return Logger.log("Querying \"" + propertyPath + "\" by selector: " + selector, level);
  },
  appendLogPrefix: function appendLogPrefix(message) {
    return Logger.LOG_PREFIX + " " + message;
  },
  log: function log(message, level) {
    var formattedMsg = Logger.LOG_PREFIX + " " + message;
    if (level === 'info') return console.info(formattedMsg);else if (level === 'warning') return console.warn(formattedMsg);else if (level === 'error') return console.error(formattedMsg);else console.log(formattedMsg);
  }
};

var internalAliasKey = /*#__PURE__*/Symbol('INTERNAL_ALIAS_KEY');
var hostIDKey = /*#__PURE__*/Symbol('HOST_ID');
var byExternalAlias = /*#__PURE__*/Symbol('SELECTORS_BY_EXTERNAL_ALIAS_STORAGE');
var byInternalAlias = /*#__PURE__*/Symbol('SELECTORS_BY_INTERNAL_ALIAS_STORAGE');

var buildException = function buildException(message, kind) {
  if (kind === void 0) {
    kind = 'INTERNAL ERROR';
  }

  return new Error(Logger.appendLogPrefix("Error type: " + kind + ", message: " + message));
};

var isConfigurableProperty = function isConfigurableProperty(host, name) {
  var descriptor = Object.getOwnPropertyDescriptor(host, name);
  return descriptor ? Boolean(descriptor.configurable) : true;
};

var makeDisplayPropName = function makeDisplayPropName(host, property) {
  return host.name + "." + property;
};

var makeInternalAlias = function makeInternalAlias(hostID, alias) {
  return "host-id: " + hostID + ", internal-alias: " + alias;
};

var registerAndAssignNewHostId = function registerAndAssignNewHostId(env, host) {
  var _env$hostIDKey;

  var hostID = ((_env$hostIDKey = env[hostIDKey]) != null ? _env$hostIDKey : 0) + 1;
  env[hostIDKey] = hostID;
  host[hostIDKey] = hostID;
  return hostID;
};

var getHostIdFromHost = function getHostIdFromHost(host) {
  return host[hostIDKey];
};

var TRANSLATE_TO_LOWER_CASE_XPATH_FN = "translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')";

var escapeQuoteSymbols = function escapeQuoteSymbols(query) {
  var escaped = [query].flatMap(inclusiveSplitByDoubleQuote).flatMap(inclusiveSplitBySingleQuote).flatMap(inclusiveSplitByBackTick).map(wrapQuoteSymbol);
  return escaped.length === 1 ? escaped[0] : "concat(" + escaped.join(', ') + ")";
};

var inclusiveSplitByDoubleQuote = function inclusiveSplitByDoubleQuote(w) {
  return w.split(/(?=[",])|(?<=["])/g);
};

var inclusiveSplitBySingleQuote = function inclusiveSplitBySingleQuote(w) {
  return w.split(/(?=[',])|(?<=['])/g);
};

var inclusiveSplitByBackTick = function inclusiveSplitByBackTick(w) {
  return w.split(/(?=[`,])|(?<=[`])/g);
};

var wrapQuoteSymbol = function wrapQuoteSymbol(symbol) {
  if (symbol === "'") return "\"'\"";
  if (symbol === '"') return "'\"'";
  if (symbol === '`') return '"`"';else return "'" + symbol + "'";
};

var mapSelectorTypeToDisplaySelectorName = function mapSelectorTypeToDisplaySelectorName(type) {
  if (type === 'attribute') return 'ByAttribute';else if (type === 'class') return 'ByClass';else if (type === 'id') return 'ById';else if (type === 'type') return 'ByType';else if (type === 'selector') return 'BySelector';else if (type === 'xpath') return 'ByXPath';else if (type === 'name') return 'ByName';else if (type === 'exact-text') return 'ByExactText';else if (type === 'partial-text') return 'ByPartialText';else if (type === 'exact-link-text') return "ByExactLinkText";else if (type === 'partial-link-text') return "ByPartialLinkText";else {

    throw buildException("Unsupported selector type: " + type, 'INTERNAL ERROR');
  }
};

var DEFAULT_ATTRIBUTE = 'cypress-id';
var DEFAULT_LOGGING = false;
var DEFAULT_SEARCH_ONLY_FIRST_LEVEL_DESCENDANTS = false;
var DEFAULT_CONFIG = {
  defaultAttribute: DEFAULT_ATTRIBUTE,
  isLoggingEnabled: DEFAULT_LOGGING,
  searchOnlyFirstLevelDescendants: DEFAULT_SEARCH_ONLY_FIRST_LEVEL_DESCENDANTS
};
var CONFIG_HANDLER = {
  reset: function reset() {
    return CONFIG_HANDLER.config = _extends({}, DEFAULT_CONFIG);
  },
  configure: function configure(_ref) {
    var _ref$defaultAttribute = _ref.defaultAttribute,
        defaultAttribute = _ref$defaultAttribute === void 0 ? DEFAULT_ATTRIBUTE : _ref$defaultAttribute,
        _ref$isLoggingEnabled = _ref.isLoggingEnabled,
        isLoggingEnabled = _ref$isLoggingEnabled === void 0 ? DEFAULT_LOGGING : _ref$isLoggingEnabled,
        _ref$searchOnlyFirstL = _ref.searchOnlyFirstLevelDescendants,
        searchOnlyFirstLevelDescendants = _ref$searchOnlyFirstL === void 0 ? DEFAULT_SEARCH_ONLY_FIRST_LEVEL_DESCENDANTS : _ref$searchOnlyFirstL;
    var config = CONFIG_HANDLER.config;
    config.defaultAttribute = defaultAttribute;
    config.isLoggingEnabled = isLoggingEnabled;
    config.searchOnlyFirstLevelDescendants = searchOnlyFirstLevelDescendants;
    return config;
  },
  config: /*#__PURE__*/_extends({}, DEFAULT_CONFIG)
};
var ConfigureSelectors = CONFIG_HANDLER.configure;
var ResetSelectorsConfiguration = CONFIG_HANDLER.reset;

var getConfiguration = function getConfiguration() {
  return _extends({}, CONFIG_HANDLER.config);
};

var buildSelector = function buildSelector(selector, env) {
  var _selector$meta = selector.meta,
      host = _selector$meta.host,
      property = _selector$meta.property;

  var _registerStoragesAndS = registerStoragesAndSelector(selector, env),
      selectorsByInternalAlias = _registerStoragesAndS.selectorsByInternalAlias;

  var elementGetter = generateElementGetter(selectorsByInternalAlias, selector);

  if (isConfigurableProperty(host, property)) {
    var selectorProxy = generateSelectorProxy(elementGetter);
    assignInternalAliasToProxy(selectorProxy, selector.config.internalAlias);
    delete host[property];
    var descriptor = {
      enumerable: false,
      configurable: false,
      value: selectorProxy
    };
    return Object.defineProperty(host, property, descriptor);
  }

  var displayProp = makeDisplayPropName(host, property);
  throw buildException("Failed to assign selector - property \"" + displayProp + "\" is not 'configurable'", 'NON CONFIGURABLE FIELD');
};

var generateSelectorProxy = function generateSelectorProxy(getChainer) {
  var proxyAccessHandler = function proxyAccessHandler(proxy, field) {
    if (typeof field === 'symbol' && internalAliasKey === field) return proxy[internalAliasKey];
    var chainer = getChainer();
    var value = chainer[field];
    return typeof value === 'function' ? value.bind(chainer) : value;
  };

  return new Proxy({}, {
    get: proxyAccessHandler
  });
};

var assignInternalAliasToProxy = function assignInternalAliasToProxy(selectorProxy, internalAlias) {
  return selectorProxy[internalAliasKey] = internalAlias;
};

var registerStoragesAndSelector = function registerStoragesAndSelector(selector, env) {
  var selectorsByInternalAlias = registerSelectorsByInternalAliasStorageIfNotRegistered(env);
  registerSelectorByInternalAlias(selector, selectorsByInternalAlias);
  var host = selector.meta.host;
  var selectorsByExternalAlias = registerSelectorByExternalAliasStorageIfNotRegistered(host);
  if (selector.config.alias) registerSelectorByExternalAlias(selector, selector.config.alias, selectorsByExternalAlias);
  return {
    selectorsByInternalAlias: selectorsByInternalAlias,
    selectorsByExternalAlias: selectorsByExternalAlias
  };
};

var registerSelectorsByInternalAliasStorageIfNotRegistered = function registerSelectorsByInternalAliasStorageIfNotRegistered(env) {
  if (hasSelectorsStorage(env) === false) {
    env[byInternalAlias] = new Map();
  }

  return env[byInternalAlias];
};

var hasSelectorsStorage = function hasSelectorsStorage(env) {
  return env.hasOwnProperty(byInternalAlias);
};

var registerSelectorByInternalAlias = function registerSelectorByInternalAlias(selector, storage) {
  var internalAlias = selector.config.internalAlias;
  if (storage.has(internalAlias)) throw buildException("Element with the internal-alias \"" + internalAlias + "\" is already registered.", 'DUPLICATE ALIAS');
  return storage.set(internalAlias, selector);
};

var registerSelectorByExternalAlias = function registerSelectorByExternalAlias(selector, alias, storage) {
  if (storage.has(alias)) throw buildException("Element with the alias \"" + alias + "\" is already registered.", 'DUPLICATE ALIAS');
  return storage.set(alias, selector);
};

var registerSelectorByExternalAliasStorageIfNotRegistered = function registerSelectorByExternalAliasStorageIfNotRegistered(host) {
  return host[byExternalAlias] ? host[byExternalAlias] : host[byExternalAlias] = new Map();
};

var getStorageOfExternalAliases = function getStorageOfExternalAliases(host) {
  return host[byExternalAlias];
};

var generateElementGetter = function generateElementGetter(byInternalAlias, selector) {
  return function () {
    var configuration = getConfiguration();

    if (configuration.isLoggingEnabled) {
      Logger.logSelector(mapSelectorByType(selector, configuration), makeDisplayPropName(selector.meta.host, selector.meta.property));
    }

    var chainOfSelectors = collectSelectorsChain(byInternalAlias, selector);
    return mapSelectorConfigsToSelectorsChain(chainOfSelectors, configuration);
  };
};

var collectSelectorsChain = function collectSelectorsChain(byInternalAlias, selector, selectorsChain) {
  if (selectorsChain === void 0) {
    selectorsChain = [];
  }

  selectorsChain = [selector].concat(selectorsChain);
  var _selector$config = selector.config,
      parentAlias = _selector$config.parentAlias,
      internalParentAlias = _selector$config.internalParentAlias;

  if (parentAlias) {
    var _byExternalAlias = getStorageOfExternalAliases(selector.meta.host);

    var nextSelector = getSelectorByAliasOrThrow(_byExternalAlias, parentAlias);
    return collectSelectorsChain(byInternalAlias, nextSelector, selectorsChain);
  } else if (internalParentAlias) {
    var _nextSelector = getSelectorByAliasOrThrow(byInternalAlias, internalParentAlias);

    return collectSelectorsChain(byInternalAlias, _nextSelector, selectorsChain);
  }

  return selectorsChain;
};

var getSelectorByAliasOrThrow = function getSelectorByAliasOrThrow(storage, alias) {
  if (storage.has(alias)) return storage.get(alias);else throw buildException("Failed to retrieve parent selector by \"" + alias + "\" alias.", 'NO SUCH ALIAS');
};

var ANY_LEVEL_DESCENDANT = ' ';
var FIRST_LEVEL_DESCENDANT = '>';

var mapSelectorConfigsToSelectorString = function mapSelectorConfigsToSelectorString(selectors, configuration) {
  var mappedSelectors = selectors.map(function (selector) {
    return mapSelectorToString(selector, configuration);
  });
  var descendance = configuration.searchOnlyFirstLevelDescendants ? FIRST_LEVEL_DESCENDANT : ANY_LEVEL_DESCENDANT;
  return mappedSelectors.join(descendance);
};

var mapSelectorConfigsToSelectorsChain = function mapSelectorConfigsToSelectorsChain(selectors, configuration) {
  var mappedSelectors = mapSelectorsByType(groupSelectorsByEngineSequentially(selectors), configuration);
  return mappedSelectors.reduce(function (chain, selector, index) {
    var options = {
      timeout: selector.timeout
    };

    if (selector.engine === 'XPath') {
      var eq = selector.eq;
      chain = typeof eq === 'number' ? chain.__cypress_selectors_xpath(selector.selector, options, selector.type).eq(eq) : chain.__cypress_selectors_xpath(selector.selector, options, selector.type);
    } else {
      var isFirstInChain = 0 === index;
      chain = isFirstInChain ? chain.get(selector.selector, options) : chain.find(selector.selector, options);
    }

    return chain;
  }, cy);
};

var mapSelectorsByType = function mapSelectorsByType(groupedByEngine, configuration) {
  return groupedByEngine.map(function (group) {
    var _group$selector$confi;

    return group.engine === 'XPath' ? {
      engine: 'XPath',
      selector: mapSelectorConfigsToSelectorString([group.selector], configuration),
      timeout: (_group$selector$confi = group.selector.config.timeout) != null ? _group$selector$confi : Cypress.config().defaultCommandTimeout,
      type: group.selector.type,
      eq: group.selector.config.eq
    } : {
      engine: 'CSS',
      selector: mapSelectorConfigsToSelectorString(group.selectors, configuration),
      timeout: getMaxTimeout(group.selectors)
    };
  });
};

var getMaxTimeout = function getMaxTimeout(selectors) {
  var _Cypress$config = Cypress.config(),
      defaultCommandTimeout = _Cypress$config.defaultCommandTimeout;

  return lodash.max(selectors.map(function (_ref) {
    var _config$timeout;

    var config = _ref.config;
    return (_config$timeout = config.timeout) != null ? _config$timeout : defaultCommandTimeout;
  }));
};

var groupSelectorsByEngineSequentially = function groupSelectorsByEngineSequentially(selectors) {
  var result = [];
  var chunk = [];

  for (var _iterator = _createForOfIteratorHelperLoose(selectors), _step; !(_step = _iterator()).done;) {
    var selector = _step.value;

    if (selector.engine === 'XPath') {
      if (chunk.length === 0) result.push([selector]);else {
        result.push(chunk, [selector]);
        chunk = [];
      }
    } else chunk.push(selector);
  }

  if (chunk.length) result.push(chunk);
  return result.map(function (selectors) {
    return selectors[0].engine === 'XPath' ? {
      engine: 'XPath',
      selector: selectors[0]
    } : {
      engine: 'CSS',
      selectors: selectors
    };
  });
};

var mapSelectorToString = function mapSelectorToString(selector, configuration) {
  var stringifiedSelector = mapSelectorByType(selector, configuration);
  var eq = selector.config.eq;
  return typeof eq === 'number' && selector.engine === 'CSS' ? stringifiedSelector + ":eq(" + eq + ")" : stringifiedSelector;
};

var mapSelectorByType = function mapSelectorByType(selector, configuration) {
  var type = selector.type,
      config = selector.config;
  var value = config.value,
      attribute = config.attribute;
  if (type === 'attribute') return "[" + (attribute != null ? attribute : configuration.defaultAttribute) + "=\"" + value + "\"]";else if (type === 'class') return "." + value;else if (type === 'id') return "#" + value;else if (type === 'type') return "" + value;else if (type === 'selector') return value;else if (type === 'xpath') return value;else if (type === 'name') return "[name=\"" + value + "\"]";else if (type === 'exact-text') return mapExactTextSelector(selector);else if (type === 'partial-text') return mapPartialTextSelector(selector);else if (type === 'exact-link-text') return mapExactTextSelector(selector, 'a');else if (type === 'partial-link-text') return mapPartialTextSelector(selector, 'a');else {

    throw buildException("Unsupported selector type: " + type, 'INTERNAL ERROR');
  }
};

var mapExactTextSelector = function mapExactTextSelector(selector, forTag) {
  if (forTag === void 0) {
    forTag = '*';
  }

  var prefix = hasParent(selector) ? "./" + forTag : "//" + forTag;
  var _selector$config2 = selector.config,
      value = _selector$config2.value,
      ignoreCase = _selector$config2.ignoreCase;
  var escaped = escapeQuoteSymbols(value);
  return ignoreCase === true ? prefix + "[" + TRANSLATE_TO_LOWER_CASE_XPATH_FN + "=" + escaped.toLowerCase() + "]" : prefix + "[text()=" + escaped + "]";
};

var mapPartialTextSelector = function mapPartialTextSelector(selector, forTag) {
  if (forTag === void 0) {
    forTag = '*';
  }

  var prefix = hasParent(selector) ? "./" + forTag : "//" + forTag;
  var _selector$config3 = selector.config,
      value = _selector$config3.value,
      ignoreCase = _selector$config3.ignoreCase;
  var escaped = escapeQuoteSymbols(value);
  return ignoreCase === true ? prefix + "[contains(" + TRANSLATE_TO_LOWER_CASE_XPATH_FN + ", " + escaped.toLowerCase() + ")]" : prefix + "[contains(text(), " + escaped + ")]";
};

var hasParent = function hasParent(_ref2) {
  var _ref2$config = _ref2.config,
      parentAlias = _ref2$config.parentAlias,
      internalParentAlias = _ref2$config.internalParentAlias;
  return parentAlias !== undefined || internalParentAlias !== undefined;
};

var SUPPORT_IGNORE_CASE_CONFIGURATION = ['partial-text', 'exact-text', 'exact-link-text', 'partial-link-text'];
var SUPPORT_ATTRIBUTE_CONFIGURATION = ['attribute'];

var throwIfNotRunningInCypressEnv = function throwIfNotRunningInCypressEnv() {
  if (!cy || typeof cy.get !== 'function') throw buildException("Can't find `cy.get` function. Probably you're defining selectors outside of Cypress context. Please make sure, that you're querying elements inside Cypress tests.", 'ENVIRONMENT ERROR');
};

var validate = function validate(externalConfig, displayProperty, type) {
  var validate = lodash.flow(shouldNotProvideBothParentAndParentAlias, shouldNotProvideEmptyAlias, shouldNotProvideEmptyParentAlias, shouldNotProvideEmptyCustomAttribute, shouldNotProvideNegativeEqAttribute, shouldNotProvideNegativeTimeout, shouldProvideParentDefinedOnlyViaCypressSelectors, shouldNotProvideIgnoreCaseForNonTextSelectors, shouldNotProvideAttributeConfigForSelectorsThatDoNotSupportIt);

  var _validate = validate({
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  }),
      sanitizedConfig = _validate.externalConfig;

  return sanitizedConfig;
};

var shouldHaveType = function shouldHaveType(attribute, _ref, expectedType) {
  var externalConfig = _ref.externalConfig,
      displayProperty = _ref.displayProperty;
  var actualType = typeof externalConfig[attribute];

  if (attribute in externalConfig && actualType !== expectedType) {
    warnAboutTypeMismatch(displayProperty, attribute, expectedType, actualType);
    delete externalConfig[attribute];
  }

  return externalConfig;
};

var shouldNotProvideBothParentAndParentAlias = function shouldNotProvideBothParentAndParentAlias(_ref2) {
  var externalConfig = _ref2.externalConfig,
      type = _ref2.type,
      displayProperty = _ref2.displayProperty;
  externalConfig = shouldHaveType('parentAlias', {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  }, 'string');

  if (typeof externalConfig.parent !== 'undefined' && typeof externalConfig.parentAlias === 'string') {
    warnAboutSupplyingParentAndParentAlias(displayProperty);
    delete externalConfig['parentAlias'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var shouldNotProvideEmptyAlias = function shouldNotProvideEmptyAlias(_ref3) {
  var externalConfig = _ref3.externalConfig,
      type = _ref3.type,
      displayProperty = _ref3.displayProperty;
  externalConfig = shouldHaveType('alias', {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  }, 'string');

  if (typeof externalConfig.alias === 'string' && externalConfig.alias.length === 0) {
    warnAboutEmptyAlias(displayProperty);
    delete externalConfig['alias'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var shouldNotProvideEmptyParentAlias = function shouldNotProvideEmptyParentAlias(_ref4) {
  var externalConfig = _ref4.externalConfig,
      type = _ref4.type,
      displayProperty = _ref4.displayProperty;
  externalConfig = shouldHaveType('parentAlias', {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  }, 'string');

  if (typeof externalConfig.parentAlias === 'string' && externalConfig.parentAlias.length === 0) {
    warnAboutEmptyParentAlias(displayProperty);
    delete externalConfig['parentAlias'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var shouldNotProvideEmptyCustomAttribute = function shouldNotProvideEmptyCustomAttribute(_ref5) {
  var externalConfig = _ref5.externalConfig,
      type = _ref5.type,
      displayProperty = _ref5.displayProperty;
  externalConfig = shouldHaveType('attribute', {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  }, 'string');

  if (typeof externalConfig.attribute === 'string' && externalConfig.attribute.length === 0) {
    warnAboutEmptyCustomAttribute(displayProperty);
    delete externalConfig['attribute'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var shouldNotProvideNegativeEqAttribute = function shouldNotProvideNegativeEqAttribute(_ref6) {
  var externalConfig = _ref6.externalConfig,
      type = _ref6.type,
      displayProperty = _ref6.displayProperty;
  externalConfig = shouldHaveType('eq', {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  }, 'number');

  if (typeof externalConfig.eq === 'number' && externalConfig.eq < 0) {
    warnAboutNegativeEqAttribute(displayProperty);
    delete externalConfig['eq'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var shouldNotProvideNegativeTimeout = function shouldNotProvideNegativeTimeout(_ref7) {
  var externalConfig = _ref7.externalConfig,
      type = _ref7.type,
      displayProperty = _ref7.displayProperty;
  externalConfig = shouldHaveType('timeout', {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  }, 'number');

  if (typeof externalConfig.timeout === 'number' && externalConfig.timeout < 0) {
    warnAboutNegativeTimeout(displayProperty);
    delete externalConfig['timeout'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var shouldProvideParentDefinedOnlyViaCypressSelectors = function shouldProvideParentDefinedOnlyViaCypressSelectors(_ref8) {
  var externalConfig = _ref8.externalConfig,
      displayProperty = _ref8.displayProperty,
      type = _ref8.type;

  if ('parent' in externalConfig) {
    var parent = externalConfig.parent;

    if (typeof parent === 'undefined' || parent === null) {
      var typeOfParent = parent === null ? 'null' : 'undefined';
      throw buildException(["Selector `" + displayProperty + "` defines \"" + typeOfParent + "\" \"parent\" attribute which is not allowed - there could be 2 reasons why you see this error:", "1) You've passed \"" + typeOfParent + "\" to \"parent\" attribute - in that case just remove \"parent\" attribute or assign a proper selector to it", "2) You've declared parent selector after children selector - due to the way how TypeScript transpiles static class properties, it is not allowed to use static class properties before their declaration.", "To make this error go away just define \"parent\" before its \"children\"."].join('\n'), 'CONFIGURATION ERROR');
    }
  }

  if (externalConfig.parent && typeof externalConfig.parent[internalAliasKey] !== 'string') {
    warnAboutInvalidParent(displayProperty);
    delete externalConfig['parent'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var shouldNotProvideIgnoreCaseForNonTextSelectors = function shouldNotProvideIgnoreCaseForNonTextSelectors(_ref9) {
  var externalConfig = _ref9.externalConfig,
      displayProperty = _ref9.displayProperty,
      type = _ref9.type;
  externalConfig = shouldHaveType('ignoreCase', {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  }, 'boolean');

  if (typeof externalConfig.ignoreCase === 'boolean' && SUPPORT_IGNORE_CASE_CONFIGURATION.includes(type) === false) {
    warnAboutRedundantIgnoreCaseParam(displayProperty, type);
    delete externalConfig['ignoreCase'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var shouldNotProvideAttributeConfigForSelectorsThatDoNotSupportIt = function shouldNotProvideAttributeConfigForSelectorsThatDoNotSupportIt(_ref10) {
  var externalConfig = _ref10.externalConfig,
      displayProperty = _ref10.displayProperty,
      type = _ref10.type;

  if (typeof externalConfig.attribute !== 'undefined' && SUPPORT_ATTRIBUTE_CONFIGURATION.includes(type) === false) {
    warnAboutRedundantAttributeParam(displayProperty, type);
    delete externalConfig['attribute'];
  }

  return {
    externalConfig: externalConfig,
    displayProperty: displayProperty,
    type: type
  };
};

var warnAboutSupplyingParentAndParentAlias = function warnAboutSupplyingParentAndParentAlias(displayProperty) {
  var message = ["Selector \"" + displayProperty + "\": 'parent' and 'parentAlias' attributes can't be used together in one configuration - 'parent' has precedence over 'parentAlias' so 'parentAlias' is going to be ignored.", "To fix this warning remove either 'parent' or 'parentAlias' attribute."].join(' ');
  Logger.log(message, 'warning');
};

var warnAboutEmptyAlias = function warnAboutEmptyAlias(displayProperty) {
  var message = "Selector \"" + displayProperty + "\": 'alias' attribute can't be an empty string. Consider either removing it or supplying non empty string as an alias.";
  Logger.log(message, 'warning');
};

var warnAboutEmptyParentAlias = function warnAboutEmptyParentAlias(displayProperty) {
  var message = "Selector \"" + displayProperty + "\": 'parentAlias' attribute can't be an empty string. Consider either removing it or supplying non empty string as a parentAlias.";
  Logger.log(message, 'warning');
};

var warnAboutEmptyCustomAttribute = function warnAboutEmptyCustomAttribute(displayProperty) {
  var message = "Selector \"" + displayProperty + "\": 'attribute' attribute can't be an empty string. Consider either removing it or supplying non empty string as a custom attribute.";
  Logger.log(message, 'error');
};

var warnAboutNegativeEqAttribute = function warnAboutNegativeEqAttribute(displayProperty) {
  var message = "Selector \"" + displayProperty + "\": 'eq' attribute be a negative value.";
  Logger.log(message, 'error');
};

var warnAboutNegativeTimeout = function warnAboutNegativeTimeout(displayProperty) {
  var message = "Selector \"" + displayProperty + "\": 'timeout' attribute can't be a negative value";
  Logger.log(message, 'error');
};

var warnAboutInvalidParent = function warnAboutInvalidParent(displayProperty) {
  var message = "Selector \"" + displayProperty + "\": the value set as 'parent' is not a valid Selector.";
  Logger.log(message, 'error');
};

var warnAboutRedundantIgnoreCaseParam = function warnAboutRedundantIgnoreCaseParam(displayProperty, type) {
  var displaySelectorName = mapSelectorTypeToDisplaySelectorName(type);
  var message = "Selector \"" + displayProperty + "\": `ignoreCase` attribute is not supported by `" + displaySelectorName + "` selector.";
  Logger.log(message, 'warning');
};

var warnAboutRedundantAttributeParam = function warnAboutRedundantAttributeParam(displayProperty, type) {
  var displaySelectorName = mapSelectorTypeToDisplaySelectorName(type);
  var message = "Selector \"" + displayProperty + "\": `attribute` attribute is not supported by `" + displaySelectorName + "` selector.";
  Logger.log(message, 'warning');
};

var warnAboutTypeMismatch = function warnAboutTypeMismatch(displayProperty, attribute, expectedType, actualType) {
  var message = "Selector \"" + displayProperty + "\": attribute \"" + attribute + "\" has the wrong type: expected - " + expectedType + ", actual - " + actualType + ".";
  Logger.log(message, 'error');
};

var xpath = function xpath(subject, selector, options, type) {
  if (Cypress.dom.isElement(subject) && subject.length > 1) {
    throw buildException("Failed to find an element by XPath(\"" + selector + "\") - the parent is not an element but a collection of " + subject.length + " elements.");
  }

  var resolveResult = function resolveResult() {
    return Cypress.Promise["try"](function () {
      return evaluateXPath(selector, subject);
    }).then(function (rawValue) {
      var isElements = Array.isArray(rawValue);
      var value = Array.isArray(rawValue) ? Cypress.$(rawValue.values.length === 1 ? rawValue[0] : rawValue) : rawValue;
      if (isElements) value.selector = selector;
      /* This is to log query in error message in case of failure */
      // @ts-ignore

      return cy.verifyUpcomingAssertions(value, options, {
        onRetry: resolveResult
      });
    });
  };

  return resolveResult().then(function (result) {
    Cypress.log(generateLogEntryForXPathResult(result, selector, type));
    return result;
  });
};

var generateLogEntryForXPathResult = function generateLogEntryForXPathResult(result, selector, type) {
  var BASE = {
    'XPath Selector': selector,
    'XPath Result': result
  };
  var name = type === 'xpath' ? "XPath" : "XPath(" + mapSelectorTypeToDisplaySelectorName(type) + ")";
  if (typeof result !== 'object') return {
    name: name,
    consoleProps: function consoleProps() {
      return _extends({}, BASE, {
        'Node Type': typeof result
      });
    }
  };else {
    if ('length' in result && 'nodeType' in result === false) {
      var nodeTypes = lodash.toArray(result).map(function (r, id) {
        return id + ": " + NOTE_TYPE_TO_LABEL_MAPPING[r.nodeType];
      }).join(', ');
      if (result['length'] === 0) BASE['XPath Result'] = 'None';
      return {
        name: name,
        consoleProps: function consoleProps() {
          return _extends({}, BASE, {
            'Node Type': nodeTypes
          });
        }
      };
    }

    var nodeType = result.nodeType;
    return {
      name: name,
      consoleProps: function consoleProps() {
        return _extends({}, BASE, {
          'Node Type': NOTE_TYPE_TO_LABEL_MAPPING[nodeType] ? nodeType + " - " + NOTE_TYPE_TO_LABEL_MAPPING[nodeType] : nodeType + " - UNKNOWN_NODE_TYPE"
        });
      }
    };
  }
};

var evaluateXPath = function evaluateXPath(xpath, subject) {
  if (subject === void 0) {
    subject = getDocument();
  }

  var contextNode; // @ts-ignore

  var _ref = [cy.state('withinSubject'), cy.state('window')],
      withinSubject = _ref[0],
      document = _ref[1].document;
  if (Cypress.dom.isElement(subject)) contextNode = subject[0];else if (Cypress.dom.isDocument(subject)) contextNode = subject;else if (withinSubject) contextNode = withinSubject[0];else contextNode = document;
  var result = (contextNode.ownerDocument || contextNode).evaluate(xpath, contextNode);
  if (result.resultType === XPathResult.NUMBER_TYPE) return result.numberValue;else if (result.resultType === XPathResult.STRING_TYPE) return result.stringValue;else if (result.resultType === XPathResult.BOOLEAN_TYPE) return result.booleanValue;
  return collectNodes(result);
};

var collectNodes = function collectNodes(nodeIterator) {
  var nodes = [];
  var node = undefined;

  while (node = nodeIterator.iterateNext()) {
    nodes.push(node);
  }

  return nodes.length === 1 ? nodes[0] : nodes;
}; // @ts-ignore


var getDocument = function getDocument() {
  return cy.state('window').document;
};
/* Source of types: https://developer.mozilla.org/ru/docs/Web/API/Node/nodeType */


var NOTE_TYPE_TO_LABEL_MAPPING = /*#__PURE__*/lodash.fromPairs([[1, 'ELEMENT_NODE'], [2, 'ATTRIBUTE_NODE'], [3, 'TEXT_NODE'], [4, 'CDATA_SECTION_NODE'], [5, 'ENTITY_REFERENCE_NODE'], [6, 'ENTITY_NODE'], [7, 'PROCESSING_INSTRUCTION_NODE'], [8, 'COMMENT_NODE'], [9, 'DOCUMENT_NODE'], [10, 'DOCUMENT_TYPE_NODE'], [11, 'DOCUMENT_FRAGMENT_NODE'], [12, 'NOTATION_NODE']]);

var registerInternalXPathCommand = function registerInternalXPathCommand() {
  return Cypress.Commands.add('__cypress_selectors_xpath', {
    prevSubject: ['optional', 'element', 'document']
  }, xpath);
};

registerInternalXPathCommand();

var BuildSelectorBy = function BuildSelectorBy(type, engine) {
  return function (value, externalConfig) {
    if (externalConfig === void 0) {
      externalConfig = {};
    }

    throwIfNotRunningInCypressEnv();
    var configAttributes = ['alias', 'parentAlias', 'attribute', 'eq', 'timeout', 'parent', 'ignoreCase'];
    var safeConfig = lodash.pick(externalConfig, configAttributes);
    return function (host, property) {
      var _getHostIdFromHost;

      var displayPropName = makeDisplayPropName(host, property);

      var selectorConfig = _extends({}, validate(safeConfig, displayPropName, type), {
        value: value,
        type: type
      });

      var hostID = (_getHostIdFromHost = getHostIdFromHost(host)) != null ? _getHostIdFromHost : registerAndAssignNewHostId(cy, host);
      var internalAlias = makeInternalAlias(hostID, property);
      var internalParentAlias = selectorConfig.parent && selectorConfig.parent[internalAliasKey];

      var config = _extends({}, selectorConfig, {
        internalAlias: internalAlias
      });

      if (internalParentAlias) config.internalParentAlias = internalParentAlias;
      var meta = {
        host: host,
        property: property,
        hostID: hostID
      };
      return buildSelector({
        type: type,
        config: config,
        meta: meta,
        engine: engine
      }, cy);
    };
  };
};

var ByAttribute = /*#__PURE__*/BuildSelectorBy('attribute', 'CSS');
var ByType = /*#__PURE__*/BuildSelectorBy('type', 'CSS');
var ByClass = /*#__PURE__*/BuildSelectorBy('class', 'CSS');
var ById = /*#__PURE__*/BuildSelectorBy('id', 'CSS');
var BySelector = /*#__PURE__*/BuildSelectorBy('selector', 'CSS');
var ByName = /*#__PURE__*/BuildSelectorBy('name', 'CSS');
var ByXPath = /*#__PURE__*/BuildSelectorBy('xpath', 'XPath');
var ByExactText = /*#__PURE__*/BuildSelectorBy('exact-text', 'XPath');
var ByPartialText = /*#__PURE__*/BuildSelectorBy('partial-text', 'XPath');
var ByExactLinkText = /*#__PURE__*/BuildSelectorBy('exact-link-text', 'XPath');
var ByPartialLinkText = /*#__PURE__*/BuildSelectorBy('partial-link-text', 'XPath');
var By = {
  Attribute: ByAttribute,
  Type: ByType,
  Class: ByClass,
  Id: ById,
  Selector: BySelector,
  XPath: ByXPath,
  Name: ByName,
  Text: {
    Exact: ByExactText,
    Partial: ByPartialText
  },
  Link: {
    ExactText: ByExactLinkText,
    PartialText: ByPartialLinkText
  }
};

exports.By = By;
exports.ByAttribute = ByAttribute;
exports.ByClass = ByClass;
exports.ByExactLinkText = ByExactLinkText;
exports.ByExactText = ByExactText;
exports.ById = ById;
exports.ByName = ByName;
exports.ByPartialLinkText = ByPartialLinkText;
exports.ByPartialText = ByPartialText;
exports.BySelector = BySelector;
exports.ByType = ByType;
exports.ByXPath = ByXPath;
exports.ConfigureSelectors = ConfigureSelectors;
exports.ResetSelectorsConfiguration = ResetSelectorsConfiguration;
//# sourceMappingURL=cypress-selectors.cjs.development.js.map
